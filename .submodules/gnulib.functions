gnulib_hash()
{
    local no_git=$1

    if test "$no_git"; then
        echo "no-git"
        return
    fi

    # Compute the hash we'll use to determine whether rerunning bootstrap
    # is required. The first is just the SHA1 that selects a gnulib snapshot.
    # The second ensures that whenever we change the set of gnulib modules used
    # by this package, we rerun bootstrap to pull in the matching set of files.
    # The third ensures that whenever we change the set of local gnulib diffs,
    # we rerun bootstrap to pull in those diffs.
    git submodule status .gnulib | awk '{ print $1 }'
    git hash-object bootstrap.conf
    git ls-tree -d HEAD gnulib/local | awk '{ print $3 }'
}

gnulib_update_required()
{
    local expected=$1
    local actual=$2
    local no_git=$3

    local ret=0

    # Whenever the gnulib submodule or any of the related bits has been
    # changed in some way (see gnulib_hash) we need to update the submodule,
    # eg. run bootstrap again; updating is also needed if any of the files
    # that can only be generated through bootstrap has gone missing
    if test "$actual" = "$expected" && \
       test -f po/Makevars && test -f AUTHORS; then
        ret=1
    fi

    return "$ret"
}

gnulib_update()
{
    local expected=$1
    local actual=$2
    local no_git=$3

    local ret=0

    # Depending on whether or not an update is required, we might be able to
    # get away with simply running autoreconf, or we might have to go through
    # the bootstrap process
    if gnulib_update_required "$expected" "$actual" "$no_git"; then
        echo "Running bootstrap..."
        ./bootstrap$no_git --bootstrap-sync
        ret=$?
    else
        echo "Running autoreconf..."
        autoreconf -if
        ret=$?
    fi

    return "$ret"
}

# vim: set syntax=sh:
